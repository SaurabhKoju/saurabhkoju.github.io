<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://saurabhkoju.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://saurabhkoju.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-06-28T19:17:28+00:00</updated><id>https://saurabhkoju.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Flow Matching</title><link href="https://saurabhkoju.github.io/blog/2025/flows/" rel="alternate" type="text/html" title="Flow Matching"/><published>2025-06-27T17:00:00+00:00</published><updated>2025-06-27T17:00:00+00:00</updated><id>https://saurabhkoju.github.io/blog/2025/flows</id><content type="html" xml:base="https://saurabhkoju.github.io/blog/2025/flows/"><![CDATA[<p>This write-up is primarily based on the excellent <a href="https://diffusion.csail.mit.edu/docs/lecture-notes.pdf">lecture-notes</a>, which I encourage the readers to check out. I have tried to condense the content and simplify some derivations. I expect to follow up with a separate write-up on Diffusion and SDE.</p> <h2 id="setup">Setup</h2> <p>We want to model some data generating distribution $p_{data}$ using samples $(y_1, y_2, …, y_n)$ drawn from this distribution. We will do so by defining a map from samples from some simple distribution $p_{\text{init}}$ (for example, a gaussian distribution with zero mean and unit covariance matrix) to samples from our data generating distribution $p_{data}$. Towards this, we will define a family of intermediate variables $x_t$ drawn from distributions $p_t$ where $p_0 = p_{\text{init}}$ and $p_1 = p_{data}$ for $t \in [0, 1]$. Note that $x_t$ is defined to have the same dimensionality as the data distribution. The trajectory of $x_t$ is defined using the ODE:</p> \[\frac{d}{dt}x_t = u_t(x_t)\] <p>where we want to learn $u_t$ such that drawing different samples $x_0$ from $p_{\text{init}}$ and following this ODE from $t = 0$ to $t = 1$ will lead to different samples from $p_{data}$. <br/> Note that $u_t$ is time dependent and learns a function with same input/output dimensionality as the data. Thus, we can interpret it as learning a vector field in the data space which tells at each time how to nudge each point such that starting from points drawn from $p_{\text{init}}$ at $t = 0$ and evolving it to $t = 1$, we end up with different samples from $p_{data}$. <br/> Here $u_t$ is said to describe a flow.</p> <h2 id="sampling">Sampling</h2> <p>If we have such a $u_t$ we can simulate it to draw samples from $p_{data}$, for example, using the Euler Method with:</p> \[\begin{aligned} x_0 &amp;\sim p_{\text{init}}&amp; \\ x_{t+h} &amp;= x_t + h \cdot u_t(x_t) \quad\ \ t = [0, h, 2h, ..., (n-1)h] \end{aligned}\] <p>where $n$ is number of steps and $h=1/n$ is the step-size. <br/> To learn such a $u_t$ we will try to explicitly construct a target $u_t$ which has this desired property.</p> <h2 id="conditional-flow">Conditional Flow</h2> <p>First, instead of constructing flow for the whole data, we will construct flow for any single data-point $y$: $u_{t, y}$ such that evolving this flow from $t = 0$ to $t = 1$ will land us on $y$ for any $x_0$ drawn from $p_{\text{init}}$.</p> \[\begin{aligned} x_0 &amp;\sim p_0 \\ \frac{d}{dt}x_t \quad&amp;= u_{t,y}(x_t) \\ x_1 \quad&amp;= y \end{aligned}\] <p>To construct this flow we can construct a set of <em>conditional interpolating distributions</em> $p(x_t \mid y)$ which describes the distribution of $x_t$ at each t. We have $p(x_0 \mid y)$ = $p_{\text{init}}$ and since $p(x_t \mid y)$ is concentrated on a single point y at $t = 1$, we can model this as a Dirac-Delta distribution $\delta(y)$. It is called <em>conditional interpolating distribution</em> because for a given $y$ it interpolates between $p_{\text{init}}$ and the sample $y$. We can use this later to construct a <em>marginal interpolating distribution</em> and the corresponding <em>marginal flow</em> which will interpolate between $p_{\text{init}}$ and $p_{data}$ as required.</p> <h3 id="example">Example</h3> <p>We can define an example <em>conditional interpolating distribution</em> using gaussian distribution as:</p> \[p(x_t|y) = \mathcal{N}(\alpha_t\ y, \beta_t\ I)\] <p>where $\alpha_t$ and $\beta_t$ are defined such that</p> \[\begin{align*} \alpha_0 = 0 \quad \beta_0 = 1 \\ \alpha_1 = 1 \quad \beta_1 = 0 \end{align*}\] <p>Verify for yourself that $p_{\text{init}} := p(x_0 \mid y) = \mathcal{N}(0, I)$ and $p(x_1 \mid y) = \delta(y)$. <br/> We can now construct a <em>conditional trajectory</em> $x_t$ that each $x_0 \sim p_{\text{init}}$ takes such that $x_t$ will follow the <em>conditional interpolating distribution</em> $p(x_t \mid y)$ by defining the trajectory as:</p> \[x_t = \alpha_ty + \beta_tx_0\] <p>for each $x_0$ <br/> Since $x_0$ itself is normally distributed with zero mean and unit co-variance, you can verify for yourself that the defined $x_t$ will follow the required Normal distribution outlined above. <br/> We simply have to take time derivative of this $x_t$ to get the <em>conditional flow</em></p> \[u_{t,y}(x_t) = \frac{d}{dt}x_t = \dot{\alpha_t}y+\dot{\beta_t}x_0 = \dot{\alpha_t}y+\frac{\dot{\beta_t}}{\beta_t}(x_t - \alpha_ty))\] <h2 id="marginal-flow">Marginal Flow</h2> <p>Define <em>marginal interpolating distribution</em> of random variable $x_t$ as</p> \[p(x_t) = \int p(x_t|y)p_{data}(y) \, dy\] <p>i.e. to sample $x_t$, we sample $y$ from $p_{data}$, then we sample $x_t$ from $p(x_t \mid y)$. The resulting distribution of $x_t$ is defined as the <em>marginal interpolating distribution</em>. <br/> We can verify that $p(x_0) = p_{\text{init}}$ and $p(x_1) = p_{data}$ using the definition of Dirac-Delta function. Thus, if we can construct a flow to follow this distribution, we can sample from the data distribution by simulating the ODE as outlined in the section <a href="#sampling">Sampling</a>.</p> <p><strong>Important Identity</strong> <br/> It turns out that the <em>marginal flow</em> of this distribution can be defined in terms of <em>conditional flow</em> as:</p> \[u_t(x_t) = \mathbb{E}_{y \sim p(y|x_t)}[u_{t, y}(x_t)]\] <p>where $p(y \mid x_t)$ is the posterior distribution of $y$ given $x_t$, which using the Bayes rule, can be expressed as:</p> \[p(y|x_t) = \frac{p(x_t|y)\cdot p_{data}(y)}{p(x_t)}\] <p>For intuition, if we think about finitely many $y’s$, the <em>marginal flow</em> for $x_t$ can be obtained by averaging the <em>conditional flow</em> needed to reach $y$ over all the $y’s$ that $x_t$ could have come from. I hope this is somewhat intuitive, you can find the proof in the notes linked at the beginning.</p> <h2 id="training-target">Training Target</h2> <p>For any given $y$ we have seen how we can derive a conditional flow we want our model to approximate. For example, in the gaussian case we derived:</p> \[u_{t,y}^{target}(x_t) = \dot{\alpha_t}y+\frac{\dot{\beta_t}}{\beta_t}(x_t - \alpha_ty)\] <p>And the <em>marginal flow</em> we want to actually learn has the form:</p> \[u_t^{target}(x_t) = \mathbb{E}_{y \sim p(y|x_t)}[u_{t, y}^{target}(x_t)]\] <p>If we could calculate this, we could define the flow matching loss as:</p> \[\begin{aligned} \mathcal{L}(\theta) &amp;= \mathbb{E}_{t \sim [0,1],\ x_t \sim p(x_t)} \left\| u_t^{\text{target}}(x_t) - u_t^\theta(x_t) \right\|^2 \\ &amp;= \mathbb{E}_{t \sim [0,1],\ x_t \sim p(x_t)} \left\| \mathbb{E}_{y \sim p(y|x_t)}[u_{t, y}^{target}(x_t)] - u_t^\theta(x_t) \right\|^2 \end{aligned}\] <p>That is for each timestep and $x_t$, try to match flow for $x_t$ against the target flow which is average of the <em>conditional flow</em> for all the $y$ the $x_t$ could have come from. Since we cannot easily sample from the posterior to estimate the inner expectation, we will apply the following trick to rewrite the loss as:</p> \[\begin{aligned} \mathcal{L}(\theta) &amp;= \mathbb{E}_{t \sim [0,1],\ x_t \sim p(x_t)} \left\| \mathbb{E}_{y \sim p(y|x_t)}[u_{t, y}^{target}(x_t)] - u_t^\theta(x_t) \right\|^2 \\ &amp;= \mathbb{E}_{t \sim [0,1],\ x_t \sim p(x_t)} \left\| \mathbb{E}_{y \sim p(y|x_t)}[u_{t, y}^{target}(x_t)] - \mathbb{E}_{y \sim p(y|x_t)}[u_t^\theta(x_t)] \right\|^2 \end{aligned}\] <p>where, since the second term does not depend on $y$, rewriting it as expectation over $y$ makes no difference. Now the loss becomes,</p> \[\begin{aligned} \mathcal{L}(\theta) &amp;= \mathbb{E}_{t \sim [0,1],\ x_t \sim p(x_t)} \left\| \mathbb{E}_{y \sim p(y|x_t)}[u_{t, y}^{target}(x_t) - u_t^\theta(x_t)] \right\|^2 \\ &amp;= \mathbb{E}_{t \sim [0,1],\ x_t \sim p(x_t)}\left[ \mathbb{E}_{y \sim p(y|x_t)}\left\|u_{t, y}^{target}(x_t) - u_t^\theta(x_t) \right\|^2 - \operatorname{Var}_{y \sim p(y|x_t)}[u_{t, y}^{target}(x_t) - u_t^\theta(x_t)]\right]\\ \end{aligned}\] <p>Here we used the identity $\operatorname{Var}[x] = \mathbb{E}[x^2]-\mathbb{E}[x]^2$ where $\operatorname{Var}[\cdot]$ denotes the element-wise variance of the vector-valued expression, i.e., the variance is computed independently for each coordinate of the vector. Furthermore, since the second term inside the variance: $u_{t}^{\theta}(x_t)$ does not depend on $y$, it works out as:</p> \[\operatorname{Var}_{y \sim p(y|x_t)}[u_{t, y}^{target}(x_t) - u_t^\theta(x_t)] = \operatorname{Var}_{y \sim p(y|x_t)}[u_{t, y}^{target}(x_t)]\] <p>which does not depend on the parameters $\theta$. Thus, we can omit this term and write the new loss with the squared term now inside the expectation as:</p> \[\begin{aligned} \mathcal{L}(\theta) &amp;= \mathbb{E}_{t \sim [0,1],\ x_t \sim p(x_t)}\left[ \mathbb{E}_{y \sim p(y|x_t)} \left\| u_{t, y}^{target}(x_t) - u_t^\theta(x_t) \right\|^2 \right]\\ &amp;= \mathbb{E}_{t \sim [0,1],\ x_t \sim p(x_t),\ y \sim p(y|x_t)} \left\| u_{t, y}^{target}(x_t) - u_t^\theta(x_t) \right\|^2 \\ &amp;= \mathbb{E}_{t \sim [0,1],\ y \sim p_{data}(y),\ x_t \sim p(x_t|y)} \left\| u_{t, y}^{target}(x_t) - u_t^\theta(x_t) \right\|^2 \\ \end{aligned}\] <p>where, for the final step, we rewrite the expectation over the joint distribution $p(x_t,y)$ as one over $y∼p(y)$, followed by $x_t∼p(x_t \mid y)$. <br/> Notice that in the final form we don’t need to sample from the posterior distribution. Thus, we can train our model with minibatch gradient descent. We summarize the training and sampling algorithms in the following section.</p> <h2 id="final-algorithm">Final Algorithm</h2> <h3 id="training-algorithm">Training Algorithm</h3> <p><strong>Algorithm</strong>: Flow Matching Training <br/> <strong>Given</strong>: Data distribution $p_{data}$, model $u_t^\theta$, and $p(x_t \mid y)$</p> <p>For each mini-batch of data do:<br/>     1. Sample $t \sim \left[0,1\right]$<br/>     2. Sample $x_t \sim p(x_t \mid y)$<br/>     3. Compute loss $\mathcal{L}(\theta) = \lVert u_{t, y}^{target}(x_t) - u_t^\theta(x_t) \rVert^2$<br/>     4. Update model parameters $\theta$ using gradient descent on loss $\mathcal{L}(\theta)$</p> <h3 id="sampling-algorithm">Sampling Algorithm</h3> <p><strong>Algorithm</strong>: Sampling from Flow Model<br/> <strong>Given</strong>: Model $u_t^\theta$, number of steps $n$</p> <p>  1. Set $t = 0$<br/>   2. Set step-size $h = \frac{1}{n}$<br/>   3. Sample $x_0 \sim p_{\text{init}}$<br/>   4. <strong>for</strong> $i = 1, …, n$ <strong>do</strong><br/>       a. $x_{t+h} = x_t + h \cdot u_t(x_t)$<br/>       b. $t = t + h$<br/>   5. <strong>end for</strong><br/>   6. <strong>return</strong> $x_1$</p>]]></content><author><name></name></author><category term="generative-modelling"/><category term="flows"/><category term="generative-modelling"/><summary type="html"><![CDATA[An introduction to Flow Matching]]></summary></entry></feed>